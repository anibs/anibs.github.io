<!DOCTYPE html>
<html lang="en">
	<head>
		<title>WebAR</title>
		
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
		<script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
		<script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-firestore.js"></script>
		<script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-analytics.js"></script>

		<style>
			
			.intro{
				text-align:center;
				border-style: solid;
				border-color: aqua;
			}

			.centerimg {
			  display: block;
			  margin-left: auto;
			  margin-right: auto;	
			}

			.collapsible {
			  background-color: #eee;

			  color: #444;
			  cursor: pointer;
			  margin: auto;
			  margin-left: 10px;
			  padding:18px;
			  width: 100%;
			  border: none;
			  text-align: center;
			  outline: none;
			  font-size: 15px;
			}

			/* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */
			.active, .collapsible:hover {
			  background-color: #ccc;
			}

			/* Style the collapsible content. Note: hidden by default */
			.content {
			  padding: 0 18px;
			  display: none;
			  overflow: hidden;
			  width:100%;
			  height:50%;
			  margin:auto;
			  background-color: #f1f1f1;
			  font-size: 25px;
			}
			.loading{
				margin:auto;
				padding-left:150px;
			}
			
}

		</style>

	</head>
	<body>
		
		<div id="info">
			<div class='intro'>
				<p><h2>Find a horizontal plane surface and tap on the screen when you see a white circle. Enjoy!!!</h2></p>
			</div>
			</br></br>
			<img src='./aricon.png' height='100' width='100' class='centerimg'>	
		</div>
            
        <div id='div' style='position: fixed;'>
			</br></br>
			<button type="button" id="collapsible" class="collapsible">ARVANTAGE</button>
			<div class="content">
				<p id='assetinfo'>Product : </p></br>
				<p id='assetinfo'>Color : </p></br>
				<button id='one' class='extrathumbnail'></button>
				<button type='img' id='two' class='extrathumbnail' src='' height='150' width='150'>
			</div>
			
			<img id='loading' class="loading" height='50' width='50'>
		
		</div>
		
		<script type="module">



			var coll = document.getElementsByClassName("collapsible");
			var i;

			for (i = 0; i < coll.length; i++) {
			  coll[i].addEventListener("click", function() {
				this.classList.toggle("active");
				var content = this.nextElementSibling;
				if (content.style.display === "block") {
				  content.style.display = "none";
				} else {
				  content.style.display = "block";
				}
			  });
			}
			
			//var id=0;
			var location_name='';
			
			location_name=location.search;
			console.log(location_name);
			var asset_name=location_name.substring(4);
			console.log(asset_name);


			var firebaseConfig = {
				apiKey: "AIzaSyDJecdvv4l-AIl7du5YpPy-RnoSJcRHOtU",
				authDomain: "hello-world-2f407.firebaseapp.com",
				databaseURL: "https://hello-world-2f407.firebaseio.com",
				projectId: "hello-world-2f407",
				storageBucket: "hello-world-2f407.appspot.com",
				messagingSenderId: "494069966463",
				appId: "1:494069966463:web:838651b9443a334cfe014a",
				measurementId: "G-YMCEW9C328"
		        };
            // Initialize Firebase
            firebase.initializeApp(firebaseConfig);
            firebase.analytics();
			const db=firebase.firestore();
			var list_glbs=[];
			var list_names=[];
			var list_thumbnail_one=[];
			var list_thumbnail_two=[];
			let glb="";
			let name="";
			var thumbone,thumbtwo
			db.settings({timestampsInSnapshots : true});

			

			db.collection('assets').get().then((snapshot)=>{
				//console.log(snapshot.docs);
				console.log(snapshot.docs.length);
				snapshot.docs.forEach(doc=>{
					//console.log(doc.data().files[0]);
					if(asset_name==doc.data().asset_name){
						
						glb=doc.data().files[0];
						if(doc.data().files.length>2){
							thumbone=doc.data().files[2];
							//list_thumbnail_one.push(thumbone);
							thumbtwo=doc.data().files[3]
							//list_thumbnail_two.push(thumbtwo);
						}
						else{
							thumbone='';
							//list_thumbnail_one.push(thumbone);
							thumbtwo='';
							//list_thumbnail_two.push(thumbtwo);
						}
					
						name=doc.data().asset_name;
						//list_glbs.push(glb);
						//list_names.push(name);
					}
					
				})
				
				/*for(var i=0;i<list_names.length;i++){
					if(list_names[i]==asset_name){
						console.log(i);
						id=i;
						break;
					}
				}*/
			})

			import * as THREE from './build/three.module.js';
			import { ARButton } from './jsm/webxr/ARButton.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			//import { DragControls } from './jsm/controls/DragControls.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			
			let container;var clicksone=0;var clickstwo=0;
			let camera, scene, renderer, controls, dragcontrols;
			let controller;
			var obj;
			let composer;
			
			var infobutton;var divObj;var loadinggif;

			let reticle;
			var changeMat, originalCol;
			let hitTestSource = null;
			let hitTestSourceRequested = false;
			var c=0;
			let spotlight,spotlight2;
			
			init();
			animate();			

			function init() {

				container = document.getElementById('div');
				document.body.appendChild( container );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				

				const light = new THREE.AmbientLight(0xffffff, 1);
				light.position.set(10,10,10);
				const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
				directionalLight.position.set(10, 100, 10);

				directionalLight.castShadow = true;

				
				scene.add(light);
				scene.add(directionalLight);


				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );

				renderer.xr.enabled = true;
				renderer.xr.enabled = true;
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );

				controls= new OrbitControls(camera, renderer.domElement);
				controls.addEventListener('change', render);
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.target.set(0, 0, -0.2);
				controls.enableDamping = true;
				controls.dampingFactor = 0.05;
				


				let options={
					requiredFeatures:['hit-test'],
					optionalFeatures:['dom-overlay'],
				}
				options.domOverlay={root:document.getElementById('div')};
				document.body.appendChild( ARButton.createButton( renderer, options ) );



				function onSelect() {
					
						if (reticle.visible){

							const loader = new GLTFLoader();
							loader.crossOrigin='true';
							console.log(asset_name);
							//console.log(id);
							// Load a glTF resource
							loadinggif=document.createElement('image');
							document.getElementById('loading').src='./loading.gif';
							const planeGeometry = new THREE.PlaneGeometry(2000, 2000);
							planeGeometry.rotateX(-Math.PI / 2);

							const shadowMesh = new THREE.Mesh(planeGeometry, new THREE.ShadowMaterial({
								color: 0x111111,
								opacity: 0.3,
							}));	

							shadowMesh.position.setFromMatrixPosition( reticle.matrix );
							shadowMesh.name = 'shadowMesh';
							shadowMesh.receiveShadow = true;
							shadowMesh.position.y = -1.85;

							scene.add(shadowMesh);
							loader.load(

								String(glb),
								function ( gltf ) {
									var count =0 ;
									obj=gltf.scene;
									obj.scale.set(0.75, 0.75, 0.75);
									obj.rotateY( - Math.PI / 4 ),
									obj.position.setFromMatrixPosition( reticle.matrix );
									obj.position.y+=0;
									obj.castShadow=true;
									obj.traverse(function(node) {
										if (node.isMesh) {
											
											if(count==0){
												count=1;
												changeMat=node.name;
												originalCol=node.material.color.getHex();
												
												//console.log(originalCol.r, originalCol.g, originalCol.b);
											}
											node.castShadow = true;
											node.material.depthTest=true;
											node.material.depthWrite=true;
											
										}
									});
		
									scene.add(obj);

									var box = new THREE.Box3();
									box.setFromObject(obj);
									box.center(controls.target);

									controls.update();
									render();

									loadinggif=document.getElementById('loading');
									loadinggif.remove();
									var asset_nameele=document.getElementById('collapsible').textContent='MORE';
									var asset_nameele=document.getElementById('assetinfo').textContent+=asset_name;
									var imgone=document.getElementById('one');
									imgone.innerHTML='<img src='+thumbone+' height='+120+' width='+120+'/>';
									var imgtwo=document.getElementById('two');
									imgtwo.innerHTML='<img src='+thumbtwo+' height='+120+' width='+120+'/>';
									
									imgone.onclick=function MatOne() {
										
										clicksone++;
										
										obj.traverse(function(node) {
											if (node.isMesh) {
												
												if(node.name==changeMat){
													//var color1=node.material.color;
													//console.log(color1);
													if(clicksone%2==0){
														node.material.color.setHex(originalCol);
													}
													else{
														node.material.color.setHex(0xff4500);
													}
												}
											}
										});
									}
									
									imgtwo.onclick=function MatTwo() {
										clickstwo++;
										
										obj.traverse(function(node) {
											if (node.isMesh) {
												
												if(node.name==changeMat){
													//var color1=node.material.color;
													//console.log(color1);
													if(clickstwo%2==0){
														node.material.color.setHex(originalCol);
													}
													else{
														node.material.color.setHex(0xffff00);
													}
												}
											}
										});
									}

								}
								
							);
							
						}
						c+=1;
					
				}

				controller = renderer.xr.getController( 0 );
				controller.addEventListener( 'select', onSelect );
				scene.add( controller );

				reticle = new THREE.Mesh(
					new THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),
					new THREE.MeshBasicMaterial()
				);
				reticle.matrixAutoUpdate = false;
				reticle.visible = false;
				scene.add( reticle );

				window.addEventListener( 'resize', onWindowResize, false );


				renderer.domElement.addEventListener('touchstart', function(e){
					e.preventDefault();
					touchDown=true;
					touchX = e.touches[0].pageX;
					touchY = e.touches[0].pageY;
				}, false);

				renderer.domElement.addEventListener('touchend', function(e){
					e.preventDefault();
					touchDown = false;
				}, false);

				renderer.domElement.addEventListener('touchmove', function(e){
					e.preventDefault();
					
					if(!touchDown){
						return;
					}

					deltaX = e.touches[0].pageX - touchX;
					deltaY = e.touches[0].pageY - touchY;
					touchX = e.touches[0].pageX;
					touchY = e.touches[0].pageY;

					rotateObject();

				}, false);

			}

			var touchDown, touchX, touchY, deltaX, deltaY;

			function rotateObject(){
				if(obj && reticle.visible){
					obj.rotation.y += deltaX / 100;
				}
			}

				


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				//animate();
			}

			function animate() {

				renderer.setAnimationLoop( render );
				requestAnimationFrame( animate );
				controls.update();
			}

			function render( timestamp, frame ) {

				if ( frame ) {

					const referenceSpace = renderer.xr.getReferenceSpace();
					const session = renderer.xr.getSession();

					if ( hitTestSourceRequested === false ) {

						session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {

							session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {

								hitTestSource = source;

							} );

						} );

						session.addEventListener( 'end', function () {

							hitTestSourceRequested = false;
							hitTestSource = null;

						} );

						hitTestSourceRequested = true;

					}

					if ( hitTestSource ) {

						const hitTestResults = frame.getHitTestResults( hitTestSource );

						if ( hitTestResults.length ) {

							const hit = hitTestResults[ 0 ];

							reticle.visible = true;
							reticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );

						} else {

							reticle.visible = false;

						}

					}

				}
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>
